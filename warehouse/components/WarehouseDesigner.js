import React, { useState, useCallback, useRef, useEffect } from 'react';
import { DndProvider } from 'react-dnd';
import { HTML5Backend } from 'react-dnd-html5-backend';
import { v4 as uuidv4 } from 'uuid';
import WarehouseToolbar from './WarehouseToolbar';
import WarehousePalette from './WarehousePalette';
import WarehousePropertiesPanel from './WarehousePropertiesPanel';
import WarehouseDesignerCanvas from './WarehouseDesignerCanvas';
import ColorLegend from './ColorLegend';
import { getComponentColor } from '../../lib/warehouse/utils/componentColors';
import showMessage from '../../lib/warehouse/utils/showMessage';
import globalIdCache from '../../lib/warehouse/utils/globalIdCache';

const WarehouseDesigner = ({ onBack, initialLayout = null }) => {
  const [items, setItems] = useState(initialLayout?.items || []);
  const [selectedItemId, setSelectedItemId] = useState(null);
  const [mode, setMode] = useState('boundary'); // boundary, zone, unit
  const [showProperties, setShowProperties] = useState(false);
  const [showLabels, setShowLabels] = useState(true);
  const [zoomLevel, setZoomLevel] = useState(1);
  const [panOffset, setPanOffset] = useState({ x: 0, y: 0 });
  const [boundaryCreated, setBoundaryCreated] = useState(false);
  const canvasRef = useRef(null);

  // Initialize global ID cache when component mounts
  useEffect(() => {
    globalIdCache.initialize(items);
    console.log(`Global ID cache initialized with ${globalIdCache.size()} IDs`);
    
    // Cleanup: clear cache when component unmounts
    return () => {
      globalIdCache.clear();
    };
  }, []); // Only run on mount

  // Update cache when items change
  useEffect(() => {
    if (globalIdCache.isInitialized()) {
      globalIdCache.initialize(items);
    }
  }, [items]);

  const selectedItem = items.find(item => item.id === selectedItemId);
  const selectedZone = items.find(item => item.id === selectedItemId && item.containerLevel === 2);

  // Zoom handlers
  const handleZoomIn = useCallback(() => {
    setZoomLevel(prev => Math.min(prev * 1.25, 5)); // Max zoom 5x
  }, []);

  const handleZoomOut = useCallback(() => {
    setZoomLevel(prev => Math.max(prev / 1.25, 0.1)); // Min zoom 0.1x
  }, []);

  // Create warehouse boundary
  const handleCreateBoundary = useCallback(() => {
    if (boundaryCreated) {
      showMessage.warning('Warehouse boundary already exists');
      return;
    }

    const boundary = {
      id: uuidv4(),
      type: 'square_boundary',
      name: 'Warehouse 1',
      x: 50,
      y: 50,
      width: 800,
      height: 500,
      color: getComponentColor('square_boundary'), // Use fixed color
      containerLevel: 1,
      isContainer: true,
      containerPadding: 20,
      resizable: true
    };

    setItems(prev => [...prev, boundary]);
    setBoundaryCreated(true);
    setMode('zone');
  }, [boundaryCreated]);

  // Auto-generate boundary around all existing components
  const handleAutoGenerateBoundary = useCallback(() => {
    // Check if boundary already exists
    const existingBoundary = items.find(item => item.type === 'square_boundary');
    if (existingBoundary) {
      const confirm = window.confirm('A boundary already exists. Do you want to replace it with an auto-generated one?');
      if (!confirm) return;
      
      // Remove existing boundary
      setItems(prev => prev.filter(item => item.type !== 'square_boundary'));
      setBoundaryCreated(false);
    }

    // Get all non-boundary components
    const components = items.filter(item => item.type !== 'square_boundary');
    
    if (components.length === 0) {
      showMessage.warning('Please add some components first before generating a boundary.');
      return;
    }

    // Calculate bounding box of all components
    let minX = Infinity;
    let minY = Infinity;
    let maxX = -Infinity;
    let maxY = -Infinity;

    components.forEach(item => {
      minX = Math.min(minX, item.x);
      minY = Math.min(minY, item.y);
      maxX = Math.max(maxX, item.x + (item.width || 100));
      maxY = Math.max(maxY, item.y + (item.height || 80));
    });

    // Add padding around components (60px to align with grid)
    const padding = 60;
    const boundaryX = Math.max(0, minX - padding);
    const boundaryY = Math.max(0, minY - padding);
    const boundaryWidth = Math.ceil((maxX - minX + padding * 2) / 60) * 60; // Snap to 60px grid
    const boundaryHeight = Math.ceil((maxY - minY + padding * 2) / 60) * 60; // Snap to 60px grid

    // Create the auto-generated boundary
    const boundary = {
      id: uuidv4(),
      type: 'square_boundary',
      name: 'Warehouse Boundary',
      x: boundaryX,
      y: boundaryY,
      width: boundaryWidth,
      height: boundaryHeight,
      color: getComponentColor('square_boundary'),
      containerLevel: 1,
      isContainer: true,
      containerPadding: 20,
      resizable: true,
      autoGenerated: true
    };

    setItems(prev => [...prev, boundary]);
    setBoundaryCreated(true);
    
    showMessage.success(`Boundary auto-generated!\nSize: ${boundaryWidth}Ã—${boundaryHeight}px\nComponents enclosed: ${components.length}`);
  }, [items, boundaryCreated]);

  // Check if a location ID is already in use using global cache
  const isLocationInUse = useCallback((locationId, excludeItemId = null) => {
    if (!locationId) return false;
    
    // If we're checking for an update (excludeItemId provided), check if it's the same ID
    if (excludeItemId) {
      const item = items.find(i => i.id === excludeItemId);
      if (item) {
        const oldId = item.locationId || 
                     (item.locationData?.location_id) ||
                     (item.properties?.locationId) ||
                     (item.data?.locationId);
        
        // If the new ID is the same as old ID, it's not in use by others
        if (oldId && String(oldId).trim().toUpperCase() === String(locationId).trim().toUpperCase()) {
          return false;
        }
      }
    }
    
    return globalIdCache.isIdInUse(locationId);
  }, [items]);

  // Add item to canvas
  const handleAddItem = useCallback((item, x, y) => {
    // Check if the item has any form of location ID and validate its uniqueness
    const locationId = item.locationId || 
                      (item.locationData?.location_id) ||
                      (item.properties?.locationId) ||
                      (item.data?.locationId);
    
    if (locationId && isLocationInUse(locationId)) {
      showMessage.error(`Cannot add item: Location ID ${locationId} is already in use by another component`);
      return;
    }
    // Find container if dropping into one
    let containerId = null;
    let finalX = x;
    let finalY = y;

    if (item.type !== 'warehouse_boundary') {
      const container = items.find(existing => {
        if (!existing.isContainer) return false;
        return x >= existing.x && x <= existing.x + existing.width &&
               y >= existing.y && y <= existing.y + existing.height;
      });

      if (container) {
        containerId = container.id;
        // Ensure item stays within container bounds
        const padding = container.containerPadding || 10;
        finalX = Math.max(container.x + padding, Math.min(x, container.x + container.width - padding - (item.width || 100)));
        finalY = Math.max(container.y + padding, Math.min(y, container.y + container.height - padding - (item.height || 80)));
      }
    }

    // Auto-label zones
    let itemName = item.name;
    if (item.type === 'zone' && item.id === 'storage') {
      const storageZones = items.filter(i => i.type === 'zone' && i.zoneType === 'storage');
      const nextLabel = String.fromCharCode(65 + storageZones.length); // A, B, C...
      itemName = `Storage Zone ${nextLabel}`;
    }

    const newItem = {
      id: uuidv4(),
      type: item.type || 'zone',
      name: itemName,
      x: finalX,
      y: finalY,
      width: item.type === 'zone' ? 120 : 25,
      height: item.type === 'zone' ? 200 : 25,
      color: getComponentColor(item.type), // Use fixed color based on component type
      containerLevel: item.type === 'zone' ? 2 : 3,
      isContainer: item.type === 'zone',
      containerPadding: item.type === 'zone' ? 8 : 0,
      zoneType: item.id,
      containerId: containerId,
      label: item.type === 'zone' && item.id === 'storage' ? String.fromCharCode(65 + items.filter(i => i.type === 'zone' && i.zoneType === 'storage').length) : null
    };

    setItems(prev => [...prev, newItem]);
  }, [items]);

  // Move item
  const handleMoveItem = useCallback((itemId, x, y) => {
    setItems(prev => prev.map(item => 
      item.id === itemId ? { ...item, x, y } : item
    ));
  }, []);

  // Select item
  const handleSelectItem = useCallback((itemId) => {
    setSelectedItemId(itemId);
  }, []);

  // Update item properties
  const handleUpdateItem = useCallback((itemId, updates) => {
    setItems(prevItems => {
      // Get the current item being updated
      const currentItem = prevItems.find(item => item.id === itemId);
      if (!currentItem) return prevItems;
      
      // Check if locationId is being updated in any form
      const newLocationId = updates.locationId || 
                           (updates.locationData?.location_id) ||
                           (updates.properties?.locationId) ||
                           (updates.data?.locationId);
      
      // Only check if we have a location ID to validate
      if (newLocationId) {
        // Get the current location ID to check if it's being changed
        const currentLocationId = currentItem.locationId || 
                                 (currentItem.locationData?.location_id) ||
                                 (currentItem.properties?.locationId) ||
                                 (currentItem.data?.locationId);
        
        // Only validate if the location ID is actually changing
        if (String(newLocationId).trim().toUpperCase() !== String(currentLocationId || '').trim().toUpperCase()) {
          // Check if the new location ID is already in use by any other component
          if (globalIdCache.isIdInUse(newLocationId)) {
            showMessage.error(`Location ID ${newLocationId} is already in use by another component`);
            return prevItems; // Don't update if location ID is in use
          }
        }
      }

      // Update the item with new properties
      return prevItems.map(item => 
        item.id === itemId ? { ...item, ...updates } : item
      );
    });
  }, []);

  // Delete item
  const handleDeleteItem = useCallback((itemId) => {
    // Remove the item's location IDs from the global cache
    const itemToDelete = items.find(item => item.id === itemId);
    if (itemToDelete) {
      // Extract and remove all location IDs from the item
      const idsToRemove = [
        itemToDelete.locationId,
        itemToDelete.locationCode,
        itemToDelete.locationTag,
        itemToDelete.primaryLocationId,
        itemToDelete.locationData?.location_id,
        itemToDelete.properties?.locationId,
        itemToDelete.data?.locationId
      ];
      
      idsToRemove.forEach(id => {
        if (id) globalIdCache.removeId(id);
      });
      
      // Remove IDs from arrays
      if (Array.isArray(itemToDelete.locationIds)) {
        itemToDelete.locationIds.forEach(id => globalIdCache.removeId(id));
      }
      
      // Remove IDs from level-location mappings
      if (Array.isArray(itemToDelete.levelLocationMappings)) {
        itemToDelete.levelLocationMappings.forEach(mapping => {
          const id = mapping?.locationId || mapping?.locId;
          if (id) globalIdCache.removeId(id);
        });
      }
      
      // Remove IDs from compartment contents
      if (itemToDelete.compartmentContents) {
        Object.values(itemToDelete.compartmentContents).forEach(content => {
          if (content?.locationId) globalIdCache.removeId(content.locationId);
          if (content?.uniqueId) globalIdCache.removeId(content.uniqueId);
        });
      }
    }
    
    setItems(prev => prev.filter(item => item.id !== itemId));
    if (selectedItemId === itemId) {
      setSelectedItemId(null);
    }
  }, [selectedItemId, items]);

  // Mode change handler
  const handleModeChange = useCallback((newMode) => {
    if (newMode === 'boundary') {
      handleCreateBoundary();
    } else {
      setMode(newMode);
    }
  }, [handleCreateBoundary]);

  // Auto-fill zone with units
  const handleAutoFillZone = useCallback((zoneId) => {
    const zone = items.find(item => item.id === zoneId);
    if (!zone || !zone.isContainer) return;

    // Create 3x9 grid of units like in reference image
    const units = [];
    const unitWidth = 25;
    const unitHeight = 25;
    const spacing = 2;
    const startX = zone.x + zone.containerPadding;
    const startY = zone.y + zone.containerPadding;

    for (let row = 0; row < 9; row++) {
      for (let col = 0; col < 3; col++) {
        const x = startX + col * (unitWidth + spacing);
        const y = startY + row * (unitHeight + spacing);

        // Check if unit fits within zone
        if (x + unitWidth <= zone.x + zone.width - zone.containerPadding &&
            y + unitHeight <= zone.y + zone.height - zone.containerPadding) {
          
          units.push({
            id: uuidv4(),
            type: 'unit',
            name: `Unit ${zone.label}${units.length + 1}`,
            x: x,
            y: y,
            width: unitWidth,
            height: unitHeight,
            color: '#00BCD4',
            containerLevel: 3,
            containerId: zoneId,
            unitType: 'storage_bay'
          });
        }
      }
    }

    setItems(prev => [...prev, ...units]);
  }, [items]);

  // Canvas click handler
  const handleCanvasClick = useCallback(() => {
    setSelectedItemId(null);
  }, []);

  // Save layout
  const handleSave = useCallback(() => {
    const layoutData = {
      items: items,
      metadata: {
        created: new Date().toISOString(),
        version: '1.0'
      }
    };
    
    const dataStr = JSON.stringify(layoutData, null, 2);
    const dataBlob = new Blob([dataStr], { type: 'application/json' });
    const url = URL.createObjectURL(dataBlob);
    
    const link = document.createElement('a');
    link.href = url;
    link.download = 'warehouse-layout.json';
    link.click();
    
    URL.revokeObjectURL(url);
    
    // Clear the global ID cache after saving
    globalIdCache.clear();
    showMessage.success('Layout saved successfully! ID cache cleared.');
  }, [items]);

  // Label management functions
  const handleToggleLabels = useCallback(() => {
    setShowLabels(prev => !prev);
  }, []);


  const handleBulkLabelEdit = useCallback(() => {
    const zones = items.filter(item => item.containerLevel === 2);
    if (zones.length === 0) {
      showMessage.warning('No zones found to label');
      return;
    }

    const startLetter = prompt('Enter starting letter for zone labels (A-Z):', 'A');
    if (!startLetter || startLetter.length !== 1) return;

    const startCode = startLetter.toUpperCase().charCodeAt(0);
    if (startCode < 65 || startCode > 90) {
      showMessage.error('Please enter a valid letter (A-Z)');
      return;
    }

    const updatedItems = items.map(item => {
      if (item.containerLevel === 2) {
        const zoneIndex = zones.indexOf(item);
        const newLabel = String.fromCharCode(startCode + zoneIndex);
        return { ...item, label: newLabel };
      }
      return item;
    });

    setItems(updatedItems);
  }, [items]);

  const containerStyle = {
    display: 'flex',
    flexDirection: 'column',
    height: '100%',
    fontFamily: 'Arial, sans-serif',
    backgroundColor: '#161b22',
    color: '#ffffff'
  };

  const mainContentStyle = {
    display: 'flex',
    flex: 1,
    overflow: 'hidden'
  };

  const canvasContainerStyle = {
    flex: 1,
    position: 'relative',
    overflow: 'visible', // Allow labels to extend beyond canvas boundaries
    backgroundColor: '#0d1117',
    border: '1px solid #21262d',
    borderRadius: '0.5rem',
    paddingBottom: '50px' // Add space for labels below components
  };

  return (
    <DndProvider backend={HTML5Backend}>
      <div style={containerStyle}>
        {/* Top Toolbar */}
        <WarehouseToolbar
          onCreateBoundary={handleCreateBoundary}
          onAutoGenerateBoundary={handleAutoGenerateBoundary}
          onAddZone={() => setMode('zone')}
          onAddUnits={() => setMode('unit')}
          onShowProperties={() => setShowProperties(true)}
          onSave={handleSave}
          selectedZone={selectedZone}
          mode={mode}
          onModeChange={handleModeChange}
          onBack={onBack}
          showLabels={showLabels}
          onToggleLabels={handleToggleLabels}
          onBulkLabelEdit={handleBulkLabelEdit}
        />

        <div style={mainContentStyle}>
          {/* Left Sidebar - Component Palette */}
          <WarehousePalette
            mode={mode}
            onComponentSelect={() => {}}
          />

          {/* Main Canvas Area */}
          <div style={canvasContainerStyle}>
            <WarehouseDesignerCanvas
              ref={canvasRef}
              items={items}
              selectedItemId={selectedItemId}
              mode={mode}
              zoomLevel={zoomLevel}
              panOffset={panOffset}
              showLabels={showLabels}
              onAddItem={handleAddItem}
              onMoveItem={handleMoveItem}
              onSelectItem={handleSelectItem}
              onCanvasClick={handleCanvasClick}
              onAutoFillZone={handleAutoFillZone}
              onZoomIn={handleZoomIn}
              onZoomOut={handleZoomOut}
            />
          </div>

          {/* Right Properties Panel */}
          {showProperties && selectedItem && (
            <WarehousePropertiesPanel
              key={`properties-${selectedItem.id}-${items.length}`} // Force re-render when items change
              selectedItem={selectedItem}
              onUpdateItem={handleUpdateItem}
              onClose={() => setShowProperties(false)}
              isVisible={showProperties}
              allItems={items}
            />
          )}
        </div>

        {/* Color Legend */}
        <ColorLegend />
      </div>
    </DndProvider>
  );
};

export default WarehouseDesigner;
